/*-----------------------------------------------------------------------------
/ Creates semi calibrated sinus output from internal Dac CH0  - PortA.2
/ Accepts UART commands @115200 baud rate with the following format:
/	f,1000\r -> This command sets the output frequency to 1kHz
/------------------------------------------------------------------------------
/ <ihsan@kehribar.me> - September 2014
/----------------------------------------------------------------------------*/
#include <avr/io.h>	
#include <util/delay.h>
#include "xmega_digital.h"
#include "xprintf.h"
#include <stdio.h>
#include <avr/interrupt.h>

void init_dac();
void init_uart();
void sendch(uint8_t ch);
void initClock_32Mhz();

uint8_t lut[256] = {
	0x80,0x83,0x86,0x89,0x8c,0x8f,0x92,0x95,
	0x98,0x9b,0x9e,0xa2,0xa5,0xa7,0xaa,0xad,
	0xb0,0xb3,0xb6,0xb9,0xbc,0xbe,0xc1,0xc4,
	0xc6,0xc9,0xcb,0xce,0xd0,0xd3,0xd5,0xd7,
	0xda,0xdc,0xde,0xe0,0xe2,0xe4,0xe6,0xe8,
	0xea,0xeb,0xed,0xee,0xf0,0xf1,0xf3,0xf4,
	0xf5,0xf6,0xf8,0xf9,0xfa,0xfa,0xfb,0xfc,
	0xfd,0xfd,0xfe,0xfe,0xfe,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,0xfe,0xfe,0xfe,0xfd,
	0xfd,0xfc,0xfb,0xfa,0xfa,0xf9,0xf8,0xf6,
	0xf5,0xf4,0xf3,0xf1,0xf0,0xee,0xed,0xeb,
	0xea,0xe8,0xe6,0xe4,0xe2,0xe0,0xde,0xdc,
	0xda,0xd7,0xd5,0xd3,0xd0,0xce,0xcb,0xc9,
	0xc6,0xc4,0xc1,0xbe,0xbc,0xb9,0xb6,0xb3,
	0xb0,0xad,0xaa,0xa7,0xa5,0xa2,0x9e,0x9b,
	0x98,0x95,0x92,0x8f,0x8c,0x89,0x86,0x83,
	0x80,0x7c,0x79,0x76,0x73,0x70,0x6d,0x6a,
	0x67,0x64,0x61,0x5d,0x5a,0x58,0x55,0x52,
	0x4f,0x4c,0x49,0x46,0x43,0x41,0x3e,0x3b,
	0x39,0x36,0x34,0x31,0x2f,0x2c,0x2a,0x28,
	0x25,0x23,0x21,0x1f,0x1d,0x1b,0x19,0x17,
	0x15,0x14,0x12,0x11,0xf,0xe,0xc,0xb,
	0xa,0x9,0x7,0x6,0x5,0x5,0x4,0x3,
	0x2,0x2,0x1,0x1,0x1,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x2,
	0x2,0x3,0x4,0x5,0x5,0x6,0x7,0x9,
	0xa,0xb,0xc,0xe,0xf,0x11,0x12,0x14,
	0x15,0x17,0x19,0x1b,0x1d,0x1f,0x21,0x23,
	0x25,0x28,0x2a,0x2c,0x2f,0x31,0x34,0x36,
	0x39,0x3b,0x3e,0x41,0x43,0x46,0x49,0x4c,
	0x4f,0x52,0x55,0x58,0x5a,0x5d,0x61,0x64,
	0x67,0x6a,0x6d,0x70,0x73,0x76,0x79,0x7c
};

uint8_t cmdBuff[128];
volatile uint8_t in = 0;
volatile uint32_t increment = 10000000;

ISR(USARTD0_RXC_vect)
{ 
	char cmd;
	uint32_t val;
	char data = USARTD0.DATA; 
	if(data == '\r')
	{
		cmdBuff[in] = 0x00;
		if(sscanf(cmdBuff,"%c,%lu",&cmd,&val) == 2)
		{
			if(cmd == 'f')
			{
				/* Found by trial and error */
				increment = ((double)val / 2262.0) * 10000000;
				xprintf("Freq set to: %lu Hz\r\n",val);
			}
		}
		else
		{
			xprintf("Unknown command: %s\r\n",cmdBuff);
		}
		in = 0;
	}
	else
	{
		if(in < 128)
		{
			cmdBuff[in] = data;		
			in++;
		}
		else
		{
			xprintf("Buffer overflow!\r\n");
			in = 0;
		}
	}
}

int main()
{
	uint32_t pc = 0;
	initClock_32Mhz();
	init_dac();	
	init_uart();

	while(1)
	{
		pc += increment;

		DACA.CH0DATAH = lut[pc >> 24];

		while(!(DACA.STATUS & (DAC_CH1DRE_bm)));
	}
}

void sendch(uint8_t ch)
{
	while(!(USARTD0.STATUS & USART_DREIF_bm));
	USARTD0.DATA = ch;
}

void init_uart()
{
	/* Set UART pin driver states */
	pinMode(D,6,INPUT);
	pinMode(D,7,OUTPUT);

	/* Remap the UART pins */
	PORTD.REMAP = PORT_USART0_bm;

	/* 8bit */
	USARTD0.CTRLB = USART_RXEN_bm|USART_TXEN_bm;
	USARTD0.CTRLC = USART_CMODE_ASYNCHRONOUS_gc|USART_PMODE_DISABLED_gc|USART_CHSIZE_8BIT_gc;

 	/* 115200 baud rate with 32MHz clock */
    USARTD0.BAUDCTRLA = 131; USARTD0.BAUDCTRLB = (-3 << USART_BSCALE_gp);

	/* Enable UART data reception interrupt */
	USARTD0.CTRLA |= USART_DRIE_bm;
	
	/* Set UART data reception interrupt priority */
	USARTD0.CTRLA |= (1<<5);
	USARTD0.CTRLA |= (1<<4);

	/* Connect the xprintf library to UART hardware */
	xdev_out(sendch);

	/* Enable all interrupt levels */
    PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
	sei();
}

void init_dac()
{
	/* DAC is enabled on Channel 0 */
	DACA.CTRLA = (1<<0) | (1<<2);

	/* Single channel operation */
	DACA.CTRLB = DAC_CHSEL_SINGLE_gc;

	/* External 2048 mV voltage reference + Left adj for easy 8bit resolution */
	DACA.CTRLC = DAC_REFSEL_AREFA_gc | DAC_LEFTADJ_bm;

	/* OFfset calibration ... */
	DACA.CH0OFFSETCAL = 250;

	disableDigitalBuffer(A,2);
}

void initClock_32Mhz()
{
	/* Generates 32Mhz clock from internal 2Mhz clock via PLL */
	OSC.PLLCTRL = OSC_PLLSRC_RC2M_gc | 16;
	OSC.CTRL |= OSC_PLLEN_bm ;
	while((OSC.STATUS & OSC_PLLRDY_bm) == 0);
	CCP = CCP_IOREG_gc;
	CLK.CTRL = CLK_SCLKSEL_PLL_gc;
}
